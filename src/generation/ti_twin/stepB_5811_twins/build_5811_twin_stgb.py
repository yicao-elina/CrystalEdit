import os
import numpy as np
from ase.io import read, write
from ase.build import surface, make_supercell
from ase import Atoms
from ase.geometry import get_distances

# Configuration
input_cif = 'data/structures/ti_twin/Ti-bcc.cif'
output_dir = 'data/structures/ti_twin/stepB_5811_twins'
log_file = 'docs/logs/stepB_5811_twins_stgb.log'

if not os.path.exists(output_dir):
    os.makedirs(output_dir)

# Constants
# Plane (5 8 11)
miller_indices = (5, 8, 11)
# Tilt Axis in plane: [1 -2 1] (Verified dot product with 5,8,11 is 0)
tilt_axis = [1, -2, 1] 

def main():
    log_lines = []
    log_lines.append(f"Step B: (5 8 11) Twin Generation (STGB Approach)")
    log_lines.append(f"Plane: {miller_indices}")
    log_lines.append(f"Tilt Axis: {tilt_axis}")
    log_lines.append("-" * 40)
    
    # 1. Load Bulk
    try:
        bulk = read(input_cif)
        log_lines.append(f"Loaded bulk Ti: {len(bulk)} atoms")
    except Exception as e:
        print(f"Error loading {input_cif}: {e}")
        return

    # 2. Construct Grain A (Oriented Slab)
    # We use ase.build.surface to orient the crystal such that (5 8 11) is parallel to the XY plane (Normal along Z).
    # This effectively applies the rotation R to align [5 8 11] to Z.
    # Note: ase.build.surface tries to find a periodic unit cell in XY.
    
    # We need to ensure the Tilt Axis [1 -2 1] is aligned with a cell vector (say Y or X) to make the rotation operations easy?
    # ASE surface aligns the first vector along x?
    # Let's inspect the generated cell.
    
    # Generate a thin slab first to check orientation
    # We need minimal thickness to define the periodicity.
    grain_a_prim = surface(bulk, miller_indices, layers=1, vacuum=0)
    
    # Align the in-plane vectors if possible?
    # Current cell vectors of grain_a_prim:
    cell = grain_a_prim.get_cell()
    v1 = cell[0]
    v2 = cell[1]
    
    log_lines.append(f"Grain A Primitive Surface Basis:")
    log_lines.append(f"  a1: {v1}")
    log_lines.append(f"  a2: {v2}")
    
    # We want to build a supercell that is substantial.
    # Target Thickness ~ 30-40 A per grain.
    # Target Lateral ~ Periodic.
    
    # 3. Create Grain A Slab
    # Calculate d_spacing for (5 8 11)
    # d = a_lattice / sqrt(h^2+k^2+l^2)
    # 210 = 5^2+8^2+11^2
    a_lat = bulk.cell.cellpar()[0]
    d_spacing = a_lat / np.sqrt(210)
    log_lines.append(f"  d_spacing (5 8 11): {d_spacing:.4f} A")
    
    target_thickness = 30.0 # Angstroms per grain
    n_layers = int(np.ceil(target_thickness / d_spacing))
    
    log_lines.append(f"  Target Thickness: {target_thickness} A -> {n_layers} planes")
    
    grain_a = surface(bulk, miller_indices, layers=n_layers, vacuum=0)
    grain_a.center(vacuum=0)
    
    # Lateral Supercell?
    # Keep it minimal periodic (1x1) or expand?
    # User said "Periodic 3D supercell". Minimal is periodic.
    # But usually for GBs we might want slightly larger to avoid self-interaction of defects?
    # For a perfect twin, minimal is fine.
    
    # 4. Construct Grain B (Rotation/Mirror)
    # Symmetric Tilt: Grain B is the mirror image of Grain A across the (5 8 11) plane.
    # For Centrosymmetric BCC, Mirror Reflection is crystallographically equivalent to a 180 degree rotation 
    # about the normal (Twist) OR 180 degree rotation about an axis in the plane perpendicular to the normal (Tilt).
    # To implement "Rotation ±θ/2", we note that Grain A is already rotated by +θ/2 relative to the reference 
    # (if we define reference as the bisector).
    # Grain B can be generated by rotating Grain A by 180 degrees around the Tilt Axis [1 -2 1]?
    # Wait, ASE surface might not align [1 -2 1] to Cartesian axes.
    # Let's use the Mirror operation across the Z-plane (which is (5 8 11)).
    # This guarantees the Twin relationship regardless of in-plane rotation.
    
    grain_b = grain_a.copy()
    pos_b = grain_b.get_positions()
    
    # Mirror across Z=0
    # Current Grain A is centered at Z=0?
    # Usually surface() puts it in 0..Thickness.
    # Let's center A at -Thickness/2?
    # No, let's stack them: A is bottom, B is top.
    
    z_max_a = np.max(grain_a.positions[:, 2])
    
    # Reflect B z-coordinates
    # We want B to be the mirror of A.
    # If A has atoms at z, B should have atoms at -z (relative to interface).
    # But we want to stack them.
    # Let's say Interface is at Z_int.
    # A is below Z_int. B is above.
    # A point z in A maps to 2*Z_int - z in B.
    
    # Let's just reflect coordinate Z -> -Z
    pos_b[:, 2] *= -1
    grain_b.set_positions(pos_b)
    
    # Now Grain B is "upside down".
    # We need to place it on top of Grain A.
    # Find Z extent.
    z_min_b = np.min(grain_b.positions[:, 2])
    
    # Shift B so that its bottom matches A's top + spacing?
    # Interplanar spacing at the boundary should be maintained (approx d_spacing).
    # Ideal separation: d_spacing.
    # If A ends at Z_max_a, the next plane (virtual) is at Z_max_a + d_spacing.
    # If B starts at Z_min_b.
    # Shift = (Z_max_a + d_spacing) - Z_min_b.
    
    # Note: This simple stacking assumes the surface cut was "perfect" (e.g. between planes).
    # If the cut was through a plane (unlikely for discrete atoms), we check z levels.
    # z levels in A are discrete.
    # We want the sequence of planes to continue mirrored.
    
    shift_z = z_max_a + d_spacing - z_min_b
    grain_b.translate([0, 0, shift_z])
    
    # Combine
    # We create a new Atoms object
    # Cell dimensions:
    # XY matches A.
    # Z needs to cover A and B.
    # Also need to ensure periodicity in Z.
    # A periodic bicrystal has 2 interfaces.
    # Interface 1 (A|B) at Z ~ 0 (local).
    # Interface 2 (B|A) at Z ~ Top.
    # For the second interface to be coherent, the total thickness must be commensurate.
    # Since B is mirror of A, the sequence A -> B -> A is symmetric.
    # Is it periodic?
    # Lattice A and Lattice B are twins.
    # The A|B interface is a twin boundary.
    # The B|A interface (top of B to bottom of A) is ALSO a twin boundary with the same geometry.
    # So yes, it should be periodic.
    
    bicrystal = grain_a + grain_b
    
    # Set Cell
    # Z height:
    z_top_b = np.max(grain_b.positions[:, 2])
    z_bot_a = np.min(grain_a.positions[:, 2])
    
    # Total physical thickness
    total_h = z_top_b - z_bot_a
    # We need to add one d_spacing for the PBC wrap-around gap?
    # Top atom is at Z_top. Bottom atom at Z_bot.
    # Distance between Top and (Bottom+Lz) should be d_spacing.
    # So Lz = (Z_top + d_spacing) - Z_bot.
    # = total_h + d_spacing.
    
    lz = total_h + d_spacing
    
    # Update cell
    final_cell = grain_a.get_cell()
    final_cell[2, 2] = lz
    bicrystal.set_cell(final_cell)
    bicrystal.set_pbc([True, True, True])
    
    # 5. Overlap Removal
    # "Physically justified distance criteria"
    # Ti atomic radius ~ 1.4 A. Bond length ~ 2.8-2.9 A.
    # Safe overlap threshold: ~ 0.6 * Bond ~ 1.7 A?
    # Or density based.
    # Let's use 1.5 A as a strict clash limit (hard sphere overlap).
    # Or analyze neighbor distances.
    
    log_lines.append(f"Combined Atoms: {len(bicrystal)}")
    log_lines.append(f"Cell Z: {lz:.4f} A")
    
    # Wrap positions to cell
    bicrystal.wrap()
    
    # Calculate Distances
    # We check neighbors.
    dists = get_distances(bicrystal.get_positions(), cell=bicrystal.get_cell(), pbc=bicrystal.get_pbc())
    dist_matrix = dists[1]
    # Add diagonal large value
    np.fill_diagonal(dist_matrix, 100.0)
    
    threshold = 2.0 # Ti-Ti bond is ~2.89. 2.0 is ~70%
    
    # Identify overlaps
    # We prioritize removing atoms at the boundary?
    # Interface is at Z ~ z_max_a + d/2.
    # And Z ~ 0 (wrap around).
    
    to_remove = set()
    rows, cols = np.where(dist_matrix < threshold)
    
    for r, c in zip(rows, cols):
        if r < c: # Unique pairs
            # Check if already removed
            if r in to_remove or c in to_remove: continue
            
            # Decide which to remove
            # Remove the one closer to the "boundary plane"?
            # Or just arbitrary (higher index).
            to_remove.add(c)
            
    log_lines.append(f"Overlap Analysis (Threshold {threshold} A):")
    log_lines.append(f"  Found {len(to_remove)} atoms to remove.")
    
    # Construct final
    final_atoms = Atoms(cell=bicrystal.get_cell(), pbc=bicrystal.get_pbc())
    for i, at in enumerate(bicrystal):
        if i not in to_remove:
            final_atoms.append(at)
            
    log_lines.append(f"Final Atoms: {len(final_atoms)}")
    
    # Save
    out_cif = os.path.join(output_dir, 'Ti_5811_twin_stgb.cif')
    out_xyz = os.path.join(output_dir, 'Ti_5811_twin_stgb.xyz')
    
    write(out_cif, final_atoms)
    write(out_xyz, final_atoms)
    
    log_lines.append(f"Written to {out_cif} and {out_xyz}")
    
    with open(log_file, 'w') as f:
        f.write("\n".join(log_lines))

if __name__ == "__main__":
    main()
